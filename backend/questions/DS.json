[
  {
    "id": 1,
    "question": "What is a Data Structure?",
    "keywords": ["organization", "storage", "efficiency", "access"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A data structure is a specialized format for organizing, processing, retrieving, and storing data efficiently."
  },
  {
    "id": 2,
    "question": "What is the time complexity of accessing an element in an array by index?",
    "keywords": ["time complexity", "array", "access", "constant", "O(1)"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "The time complexity is O(1) (Constant Time) because arrays use direct addressing based on the index."
  },
  {
    "id": 3,
    "question": "Write a function to check if a Linked List has a cycle.",
    "keywords": ["linked list", "cycle", "detect", "pointer"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "bool hasCycle(Node* head) { Node *slow = head, *fast = head; while(fast && fast->next) { slow = slow->next; fast = fast->next->next; if(slow == fast) return true; } return false; }"
  },
  {
    "id": 4,
    "question": "Difference between Stack and Queue?",
    "keywords": ["LIFO", "FIFO", "stack", "queue", "order"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Stack follows LIFO (Last In First Out), whereas Queue follows FIFO (First In First Out)."
  },
  {
    "id": 5,
    "question": "What is a Binary Search Tree (BST)?",
    "keywords": ["binary tree", "sorted", "left", "right", "nodes"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A BST is a binary tree where the left child's value is less than the parent, and the right child's value is greater than the parent."
  },
  {
    "id": 6,
    "question": "Code to reverse a string using a Stack.",
    "keywords": ["reverse", "string", "stack", "push", "pop"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "string reverse(string s) { stack<char> st; for(char c : s) st.push(c); string res = \"\"; while(!st.empty()) { res += st.top(); st.pop(); } return res; }"
  },
  {
    "id": 7,
    "question": "What is the worst-case time complexity of QuickSort?",
    "keywords": ["quicksort", "worst case", "time complexity", "O(n^2)"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "The worst-case time complexity of QuickSort is O(n^2), which happens when the pivot is the smallest or largest element."
  },
  {
    "id": 8,
    "question": "What is a Hash Table?",
    "keywords": ["hash table", "key-value", "mapping", "lookup"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Hash Table is a data structure that implements an associative array abstract data type, a structure that can map keys to values."
  },
  {
    "id": 9,
    "question": "Write a recursive function to calculate the height of a binary tree.",
    "keywords": ["tree", "height", "recursion", "depth"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int height(Node* node) { if (node == NULL) return 0; return 1 + max(height(node->left), height(node->right)); }"
  },
  {
    "id": 10,
    "question": "What is a Priority Queue?",
    "keywords": ["priority", "queue", "heap", "order"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Priority Queue is a type of queue where each element has a priority, and elements with higher priority are served before lower priority ones."
  },
  {
    "id": 11,
    "question": "Difference between Array and Linked List?",
    "keywords": ["array", "linked list", "memory", "contiguous", "dynamic"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Arrays have fixed size and contiguous memory. Linked Lists have dynamic size and non-contiguous memory using pointers."
  },
  {
    "id": 12,
    "question": "Code to insert a node at the beginning of a Linked List.",
    "keywords": ["insert", "linked list", "head", "node"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "void push(Node** head_ref, int new_data) { Node* new_node = new Node(); new_node->data = new_data; new_node->next = (*head_ref); (*head_ref) = new_node; }"
  },
  {
    "id": 13,
    "question": "What is an AVL Tree?",
    "keywords": ["AVL", "balanced", "binary search tree", "height"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "An AVL tree is a self-balancing Binary Search Tree where the difference between heights of left and right subtrees cannot be more than one."
  },
  {
    "id": 14,
    "question": "What is a Graph?",
    "keywords": ["graph", "vertices", "edges", "nodes", "connections"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Graph is a non-linear data structure consisting of nodes (vertices) and edges that connect these nodes."
  },
  {
    "id": 15,
    "question": "Code for Binary Search (Iterative).",
    "keywords": ["binary search", "iterative", "sorted", "mid"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "int binarySearch(int arr[], int l, int r, int x) { while (l <= r) { int m = l + (r - l) / 2; if (arr[m] == x) return m; if (arr[m] < x) l = m + 1; else r = m - 1; } return -1; }"
  },
  {
    "id": 16,
    "question": "What is BFS?",
    "keywords": ["BFS", "breadth", "traversal", "graph", "queue"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "BFS (Breadth-First Search) is a graph traversal algorithm that explores neighbor nodes first, before moving to the next level neighbors."
  },
  {
    "id": 17,
    "question": "What is DFS?",
    "keywords": ["DFS", "depth", "traversal", "graph", "stack"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "DFS (Depth-First Search) is a graph traversal algorithm that explores as far as possible along each branch before backtracking."
  },
  {
    "id": 18,
    "question": "Code to implement a Queue using Arrays.",
    "keywords": ["queue", "array", "enqueue", "dequeue"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "class Queue { int front, rear, size; unsigned capacity; int* array; ... void enqueue(int item) { array[rear] = item; rear = (rear + 1) % capacity; size++; } }"
  },
  {
    "id": 19,
    "question": "What is a Doubly Linked List?",
    "keywords": ["doubly", "linked list", "prev", "next", "pointers"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Doubly Linked List is a linked list where each node contains a reference to both the next node and the previous node."
  },
  {
    "id": 20,
    "question": "What is the time complexity of Merge Sort?",
    "keywords": ["merge sort", "time complexity", "O(n log n)", "divide and conquer"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "The time complexity of Merge Sort is O(n log n) in all cases (best, average, and worst)."
  },
  {
    "id": 21,
    "question": "Code to reverse an array.",
    "keywords": ["reverse", "array", "swap", "loop"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "void reverseArray(int arr[], int start, int end) { while (start < end) { int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; start++; end--; } }"
  },
  {
    "id": 22,
    "question": "What is Hashing?",
    "keywords": ["hashing", "key", "index", "map", "function"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Hashing is the process of mapping keys to specific values in a hash table using a hash function."
  },
  {
    "id": 23,
    "question": "What is a Heap?",
    "keywords": ["heap", "tree", "complete", "min-heap", "max-heap"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Heap is a special Tree-based data structure in which the tree is a complete binary tree. It can be a Max-Heap or Min-Heap."
  },
  {
    "id": 24,
    "question": "Code to find the factorial of a number using recursion.",
    "keywords": ["factorial", "recursion", "math", "function"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int factorial(int n) { if (n == 0) return 1; return n * factorial(n - 1); }"
  },
  {
    "id": 25,
    "question": "What is Dynamic Programming?",
    "keywords": ["dynamic programming", "optimization", "subproblems", "memoization"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "Dynamic Programming is a method for solving complex problems by breaking them down into simpler subproblems and storing their solutions."
  },
  {
    "id": 26,
    "question": "What is the difference between Tree and Graph?",
    "keywords": ["tree", "graph", "cycle", "root", "hierarchical"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Tree is a hierarchical structure without cycles. A Graph is a network structure that can contain cycles."
  },
  {
    "id": 27,
    "question": "Code to implement Bubble Sort.",
    "keywords": ["bubble sort", "sort", "swap", "loop"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "void bubbleSort(int arr[], int n) { for (int i = 0; i < n-1; i++) for (int j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]); }"
  },
  {
    "id": 28,
    "question": "What is a Trie?",
    "keywords": ["trie", "prefix", "tree", "search", "strings"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "A Trie (Prefix Tree) is a tree-like data structure used to store a dynamic set of strings, where keys are usually strings."
  },
  {
    "id": 29,
    "question": "What is the 'Top' operation in a Stack?",
    "keywords": ["stack", "top", "peek", "element"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "The 'Top' (or Peek) operation returns the element currently at the top of the stack without removing it."
  },
  {
    "id": 30,
    "question": "Code to delete a node from a BST.",
    "keywords": ["delete", "BST", "node", "tree"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "code",
    "answer": "Node* deleteNode(Node* root, int key) { if (root == NULL) return root; if (key < root->key) root->left = deleteNode(root->left, key); else if (key > root->key) root->right = deleteNode(root->right, key); else { ... } return root; }"
  },
  {
    "id": 31,
    "question": "What is a Circular Linked List?",
    "keywords": ["circular", "linked list", "loop", "last", "first"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Circular Linked List is a variation where the last node points back to the first node instead of null."
  },
  {
    "id": 32,
    "question": "What is Space Complexity?",
    "keywords": ["space", "complexity", "memory", "storage"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Space Complexity represents the amount of memory space required by an algorithm to execute as a function of the input size."
  },
  {
    "id": 33,
    "question": "Code for Inorder Traversal of a Tree.",
    "keywords": ["inorder", "traversal", "tree", "left-root-right"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "void printInorder(struct Node* node) { if (node == NULL) return; printInorder(node->left); cout << node->data << \" \"; printInorder(node->right); }"
  },
  {
    "id": 34,
    "question": "What is a Sparse Matrix?",
    "keywords": ["sparse", "matrix", "zero", "elements"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Sparse Matrix is a matrix in which most of the elements are zero."
  },
  {
    "id": 35,
    "question": "What is Linear Search?",
    "keywords": ["linear", "search", "sequential", "scan"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Linear Search is a simple search algorithm that checks every element in the list sequentially until a match is found."
  },
  {
    "id": 36,
    "question": "Code to enqueue in a Circular Queue.",
    "keywords": ["circular queue", "enqueue", "modulo", "full"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "void enqueue(int element) { if ((rear + 1) % SIZE == front) { cout << \"Queue is full\"; } else { rear = (rear + 1) % SIZE; items[rear] = element; } }"
  },
  {
    "id": 37,
    "question": "What is a Deque?",
    "keywords": ["deque", "double-ended", "queue", "insertion", "deletion"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Deque (Double Ended Queue) is a queue where insertion and deletion can be performed from both the front and the rear."
  },
  {
    "id": 38,
    "question": "What is Selection Sort?",
    "keywords": ["selection sort", "minimum", "swap", "position"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Selection Sort works by repeatedly finding the minimum element from the unsorted part and putting it at the beginning."
  },
  {
    "id": 39,
    "question": "Code to find the length of a Linked List.",
    "keywords": ["length", "linked list", "count", "iterate"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int getCount(Node* head) { int count = 0; Node* current = head; while (current != NULL) { count++; current = current->next; } return count; }"
  },
  {
    "id": 40,
    "question": "What is Recursion?",
    "keywords": ["recursion", "function", "call", "self"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Recursion is a programming technique where a function calls itself to solve a problem."
  },
  {
    "id": 41,
    "question": "What is a B-Tree?",
    "keywords": ["B-tree", "self-balancing", "search", "disk"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "A B-Tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time."
  },
  {
    "id": 42,
    "question": "Code to check if a string is a palindrome.",
    "keywords": ["palindrome", "string", "check", "reverse"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "bool isPalindrome(string S) { string P = S; reverse(P.begin(), P.end()); return S == P; }"
  },
  {
    "id": 43,
    "question": "What is Postorder Traversal?",
    "keywords": ["postorder", "traversal", "tree", "left-right-root"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Postorder Traversal visits the Left subtree, then the Right subtree, and finally the Root node."
  },
  {
    "id": 44,
    "question": "What is Preorder Traversal?",
    "keywords": ["preorder", "traversal", "tree", "root-left-right"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Preorder Traversal visits the Root node first, then the Left subtree, and finally the Right subtree."
  },
  {
    "id": 45,
    "question": "Code to merge two sorted arrays.",
    "keywords": ["merge", "sorted", "arrays", "combine"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "void mergeArrays(int arr1[], int arr2[], int n1, int n2, int arr3[]) { int i=0, j=0, k=0; while(i<n1 && j<n2) { if (arr1[i]<arr2[j]) arr3[k++] = arr1[i++]; else arr3[k++] = arr2[j++]; } ... }"
  },
  {
    "id": 46,
    "question": "What is a Complete Binary Tree?",
    "keywords": ["complete", "binary tree", "levels", "filled"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Complete Binary Tree is a binary tree where all levels are completely filled except possibly the last, which is filled from the left."
  },
  {
    "id": 47,
    "question": "What is a Full Binary Tree?",
    "keywords": ["full", "binary tree", "children", "0 or 2"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Full Binary Tree is a binary tree where every node has either 0 or 2 children."
  },
  {
    "id": 48,
    "question": "Code to swap two numbers without a temp variable.",
    "keywords": ["swap", "variable", "xor", "math"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "x = x + y; y = x - y; x = x - y;"
  },
  {
    "id": 49,
    "question": "What is Collision in Hashing?",
    "keywords": ["collision", "hashing", "key", "same index"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Collision occurs when two different keys hash to the same index in a hash table."
  },
  {
    "id": 50,
    "question": "How to resolve Hash Collisions?",
    "keywords": ["resolve", "collision", "chaining", "open addressing"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Common methods are Separate Chaining (using linked lists) and Open Addressing (Linear Probing, Quadratic Probing)."
  },
  {
    "id": 51,
    "question": "Code to implement a Stack using Array.",
    "keywords": ["stack", "array", "push", "pop"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "class Stack { int top; int a[MAX]; ... bool push(int x) { if (top >= (MAX - 1)) return false; else { a[++top] = x; return true; } } }"
  },
  {
    "id": 52,
    "question": "What is the Fibonacci Series?",
    "keywords": ["fibonacci", "series", "sequence", "sum"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "The Fibonacci Series is a sequence where each number is the sum of the two preceding ones, usually starting with 0 and 1."
  },
  {
    "id": 53,
    "question": "What is Dijkstra's Algorithm?",
    "keywords": ["dijkstra", "shortest path", "graph", "weighted"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "Dijkstra's Algorithm finds the shortest path from a source node to all other nodes in a weighted graph."
  },
  {
    "id": 54,
    "question": "Code to find the maximum element in an array.",
    "keywords": ["max", "array", "element", "find"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int max = arr[0]; for (int i = 1; i < n; i++) if (arr[i] > max) max = arr[i];"
  },
  {
    "id": 55,
    "question": "What is a Red-Black Tree?",
    "keywords": ["red-black", "tree", "balanced", "color"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "A Red-Black Tree is a self-balancing binary search tree where each node has an extra bit for color (red or black) to ensure balance."
  },
  {
    "id": 56,
    "question": "What is Adjacency Matrix?",
    "keywords": ["adjacency", "matrix", "graph", "representation"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "An Adjacency Matrix is a 2D array used to represent a graph, where arr[i][j] indicates an edge between vertex i and vertex j."
  },
  {
    "id": 57,
    "question": "Code to remove duplicates from a sorted array.",
    "keywords": ["remove", "duplicates", "sorted", "array"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "int removeDuplicates(int arr[], int n) { if (n==0 || n==1) return n; int j = 0; for (int i=0; i < n-1; i++) if (arr[i] != arr[i+1]) arr[j++] = arr[i]; arr[j++] = arr[n-1]; return j; }"
  },
  {
    "id": 58,
    "question": "What is Adjacency List?",
    "keywords": ["adjacency", "list", "graph", "linked list"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "An Adjacency List represents a graph as an array of linked lists. The index represents a vertex and the linked list contains its neighbors."
  },
  {
    "id": 59,
    "question": "What is Shell Sort?",
    "keywords": ["shell sort", "insertion", "gap", "sort"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Shell Sort is a generalization of Insertion Sort that allows the exchange of items that are far apart."
  },
  {
    "id": 60,
    "question": "Code to calculate power (x^y) recursively.",
    "keywords": ["power", "recursion", "math", "exponent"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int power(int x, int y) { if (y == 0) return 1; return x * power(x, y - 1); }"
  },
  {
    "id": 61,
    "question": "What is the time complexity of Bubble Sort?",
    "keywords": ["bubble sort", "time complexity", "O(n^2)", "slow"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "The average and worst-case time complexity of Bubble Sort is O(n^2)."
  },
  {
    "id": 62,
    "question": "What is Memoization?",
    "keywords": ["memoization", "caching", "dynamic programming", "store"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Memoization is an optimization technique used to speed up computer programs by storing the results of expensive function calls."
  },
  {
    "id": 63,
    "question": "Code to find the middle of a Linked List.",
    "keywords": ["middle", "linked list", "slow", "fast"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "void printMiddle(Node *head) { Node *slow_ptr = head; Node *fast_ptr = head; while (fast_ptr != NULL && fast_ptr->next != NULL) { fast_ptr = fast_ptr->next->next; slow_ptr = slow_ptr->next; } printf(\"%d\", slow_ptr->data); }"
  },
  {
    "id": 64,
    "question": "What is a Spanning Tree?",
    "keywords": ["spanning tree", "graph", "subgraph", "vertices"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Spanning Tree is a subgraph that is a tree and connects all the vertices together."
  },
  {
    "id": 65,
    "question": "What is Prim's Algorithm?",
    "keywords": ["prim", "MST", "graph", "greedy"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "Prim's Algorithm is a greedy algorithm used to find the Minimum Spanning Tree (MST) for a weighted undirected graph."
  },
  {
    "id": 66,
    "question": "Code to reverse a string iteratively.",
    "keywords": ["reverse", "string", "loop", "swap"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "void reverseStr(string& str) { int n = str.length(); for (int i = 0; i < n / 2; i++) swap(str[i], str[n - i - 1]); }"
  },
  {
    "id": 67,
    "question": "What is Kruskal's Algorithm?",
    "keywords": ["kruskal", "MST", "edges", "sort"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "Kruskal's Algorithm finds the Minimum Spanning Tree by sorting edges by weight and adding them if they don't form a cycle."
  },
  {
    "id": 68,
    "question": "What is Topological Sort?",
    "keywords": ["topological", "sort", "DAG", "ordering"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "Topological Sort is a linear ordering of vertices for a Directed Acyclic Graph (DAG) such that for every edge u-v, u comes before v."
  },
  {
    "id": 69,
    "question": "Code to find GCD of two numbers.",
    "keywords": ["GCD", "math", "recursion", "modulo"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); }"
  },
  {
    "id": 70,
    "question": "What is an Inverted Index?",
    "keywords": ["inverted", "index", "search", "mapping"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "An Inverted Index is an index data structure storing a mapping from content (like words) to its locations in a document."
  },
  {
    "id": 71,
    "question": "What is Heap Sort?",
    "keywords": ["heap sort", "sort", "heap", "binary tree"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Heap Sort is a comparison-based sorting technique based on the Binary Heap data structure."
  },
  {
    "id": 72,
    "question": "Code to check if two strings are Anagrams.",
    "keywords": ["anagram", "string", "sort", "compare"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "bool areAnagram(string str1, string str2) { sort(str1.begin(), str1.end()); sort(str2.begin(), str2.end()); return str1 == str2; }"
  },
  {
    "id": 73,
    "question": "What is Interpolation Search?",
    "keywords": ["interpolation", "search", "sorted", "uniform"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Interpolation Search is an improved variant of Binary Search for uniformly distributed sorted arrays, probing based on the value."
  },
  {
    "id": 74,
    "question": "What is a Suffix Tree?",
    "keywords": ["suffix", "tree", "string", "substring"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "A Suffix Tree is a compressed trie containing all the suffixes of the given text as their keys and positions in the text as their values."
  },
  {
    "id": 75,
    "question": "Code to print Fibonacci series using iteration.",
    "keywords": ["fibonacci", "series", "loop", "print"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "void printFib(int n) { int t1 = 0, t2 = 1, nextTerm = 0; for (int i = 1; i <= n; ++i) { cout << t1 << \" \"; nextTerm = t1 + t2; t1 = t2; t2 = nextTerm; } }"
  },
  {
    "id": 76,
    "question": "What is the degree of a vertex?",
    "keywords": ["degree", "vertex", "graph", "edges"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "The degree of a vertex in a graph is the number of edges connected to it."
  },
  {
    "id": 77,
    "question": "What is a Path in a Graph?",
    "keywords": ["path", "graph", "sequence", "vertices"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Path is a sequence of vertices where each adjacent pair is connected by an edge."
  },
  {
    "id": 78,
    "question": "Code to search in a BST.",
    "keywords": ["search", "BST", "recursion", "node"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "Node* search(Node* root, int key) { if (root == NULL || root->key == key) return root; if (root->key < key) return search(root->right, key); return search(root->left, key); }"
  },
  {
    "id": 79,
    "question": "What is a Leaf Node?",
    "keywords": ["leaf", "node", "tree", "child"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Leaf Node is a node in a tree that has no children."
  },
  {
    "id": 80,
    "question": "What is Level Order Traversal?",
    "keywords": ["level order", "traversal", "BFS", "tree"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Level Order Traversal is a tree traversal method where nodes are visited level by level from top to bottom, left to right."
  },
  {
    "id": 81,
    "question": "Code to insert element in an Array.",
    "keywords": ["insert", "array", "position", "shift"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "for (int i = n; i >= pos; i--) arr[i] = arr[i - 1]; arr[pos - 1] = x;"
  },
  {
    "id": 82,
    "question": "What is a Self-Balancing Tree?",
    "keywords": ["self-balancing", "tree", "height", "AVL", "Red-Black"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Self-Balancing Tree is a BST that automatically keeps its height small (logarithmic) after insertions and deletions."
  },
  {
    "id": 83,
    "question": "What is Radix Sort?",
    "keywords": ["radix", "sort", "digit", "integer"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "Radix Sort is a non-comparative sorting algorithm that sorts integers by processing individual digits."
  },
  {
    "id": 84,
    "question": "Code to delete an element from an Array.",
    "keywords": ["delete", "array", "shift", "position"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "for (int i = pos; i < n - 1; i++) arr[i] = arr[i + 1]; n--;"
  },
  {
    "id": 85,
    "question": "What is a 2D Array?",
    "keywords": ["2D", "array", "matrix", "rows", "columns"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A 2D Array is an array of arrays, representing a matrix with rows and columns."
  },
  {
    "id": 86,
    "question": "What is Divide and Conquer?",
    "keywords": ["divide", "conquer", "strategy", "algorithm"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Divide and Conquer is an algorithm design paradigm where a problem is broken into smaller subproblems, solved recursively, and combined."
  },
  {
    "id": 87,
    "question": "Code to find sum of array elements.",
    "keywords": ["sum", "array", "loop", "add"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int sum = 0; for (int i = 0; i < n; i++) sum += arr[i];"
  },
  {
    "id": 88,
    "question": "What is Greedy Algorithm?",
    "keywords": ["greedy", "algorithm", "optimization", "local"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Greedy Algorithm builds up a solution piece by piece, always choosing the next piece that offers the most immediate benefit."
  },
  {
    "id": 89,
    "question": "What is Backtracking?",
    "keywords": ["backtracking", "recursion", "undo", "solution"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Backtracking is an algorithmic-technique for solving problems recursively by trying to build a solution incrementally and removing those that fail."
  },
  {
    "id": 90,
    "question": "Code to transpose a matrix.",
    "keywords": ["transpose", "matrix", "swap", "rows", "columns"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "for (int i = 0; i < N; i++) for (int j = i+1; j < N; j++) swap(A[i][j], A[j][i]);"
  },
  {
    "id": 91,
    "question": "What is Big O Notation?",
    "keywords": ["Big O", "notation", "complexity", "upper bound"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Big O Notation describes the upper bound of an algorithm's complexity (time or space) in the worst-case scenario."
  },
  {
    "id": 92,
    "question": "What is Amortized Analysis?",
    "keywords": ["amortized", "analysis", "average", "sequence"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "Amortized Analysis finds the average running time per operation over a worst-case sequence of operations."
  },
  {
    "id": 93,
    "question": "Code to count nodes in a Linked List recursively.",
    "keywords": ["count", "linked list", "recursion", "nodes"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int getCount(Node* head) { if (head == NULL) return 0; return 1 + getCount(head->next); }"
  },
  {
    "id": 94,
    "question": "What is the height of a tree?",
    "keywords": ["height", "tree", "depth", "longest path"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "The height of a tree is the number of edges on the longest path from the root to a leaf."
  },
  {
    "id": 95,
    "question": "What is a Forest in Graph theory?",
    "keywords": ["forest", "graph", "disjoint", "trees"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Forest is a collection of disjoint trees."
  },
  {
    "id": 96,
    "question": "Code to check if a number is prime.",
    "keywords": ["prime", "number", "check", "loop"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "bool isPrime(int n) { if (n <= 1) return false; for (int i = 2; i * i <= n; i++) if (n % i == 0) return false; return true; }"
  },
  {
    "id": 97,
    "question": "What is a Multi-dimensional Array?",
    "keywords": ["multi-dimensional", "array", "indices", "complex"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Multi-dimensional Array is an array of arrays, accessed using multiple indices (e.g., 2D, 3D arrays)."
  },
  {
    "id": 98,
    "question": "What is Bucket Sort?",
    "keywords": ["bucket", "sort", "distribute", "gather"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Bucket Sort distributes elements into buckets, sorts each bucket individually, and then gathers them."
  },
  {
    "id": 99,
    "question": "Code to find min element in BST.",
    "keywords": ["min", "BST", "left", "node"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int minValue(Node* root) { Node* current = root; while (current->left != NULL) current = current->left; return current->data; }"
  },
  {
    "id": 100,
    "question": "What is Huffman Coding?",
    "keywords": ["huffman", "coding", "compression", "greedy"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "Huffman Coding is a lossless data compression algorithm that uses a greedy approach to build a prefix code tree."
  },
  {
    "id": 101,
    "question": "What is the advantage of Linked List over Array?",
    "keywords": ["linked list", "array", "dynamic", "insertion"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Linked Lists allow dynamic memory allocation and efficient insertion/deletion without shifting elements."
  },
  {
    "id": 102,
    "question": "Code to check balanced parentheses.",
    "keywords": ["balanced", "parentheses", "stack", "check"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "bool isBalanced(string expr) { stack<char> s; for (char x : expr) { if (x=='(') s.push(x); else if (!s.empty() && x==')') s.pop(); else return false; } return s.empty(); }"
  },
  {
    "id": 103,
    "question": "What is a Sentinel Node?",
    "keywords": ["sentinel", "node", "dummy", "guard"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Sentinel Node is a dummy node used to simplify boundary conditions in linked lists and trees."
  },
  {
    "id": 104,
    "question": "What is External Sorting?",
    "keywords": ["external", "sorting", "disk", "memory"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "External Sorting is a class of sorting algorithms that can handle massive amounts of data that do not fit into main memory (RAM)."
  },
  {
    "id": 105,
    "question": "Code to multiply two matrices.",
    "keywords": ["multiply", "matrix", "loop", "product"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "for(i=0;i<r;i++) for(j=0;j<c;j++) for(k=0;k<c;k++) mul[i][j]+=a[i][k]*b[k][j];"
  },
  {
    "id": 106,
    "question": "What is a Hash Function?",
    "keywords": ["hash", "function", "map", "key"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Hash Function is a function that converts a given key into an index in the hash table."
  },
  {
    "id": 107,
    "question": "What is Load Factor in Hashing?",
    "keywords": ["load factor", "hashing", "ratio", "capacity"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Load Factor is the ratio of the number of stored elements to the size of the hash table."
  },
  {
    "id": 108,
    "question": "Code to get nth Fibonacci number using recursion.",
    "keywords": ["fibonacci", "nth", "recursion", "math"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int fib(int n) { if (n <= 1) return n; return fib(n-1) + fib(n-2); }"
  },
  {
    "id": 109,
    "question": "What is a Skip List?",
    "keywords": ["skip list", "probabilistic", "linked list", "layers"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "A Skip List is a probabilistic data structure that allows fast search within an ordered sequence of elements using multiple layers of linked lists."
  },
  {
    "id": 110,
    "question": "What is a Bit Array?",
    "keywords": ["bit", "array", "bitmap", "compact"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Bit Array (Bitmap) is an array data structure that compactly stores bits."
  },
  {
    "id": 111,
    "question": "Code to find intersection of two arrays.",
    "keywords": ["intersection", "array", "common", "find"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "for(int i=0;i<n;i++) for(int j=0;j<m;j++) if(arr1[i]==arr2[j]) cout << arr1[i];"
  },
  {
    "id": 112,
    "question": "What is a Bloom Filter?",
    "keywords": ["bloom filter", "probabilistic", "set", "membership"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "A Bloom Filter is a space-efficient probabilistic data structure used to test whether an element is a member of a set."
  },
  {
    "id": 113,
    "question": "What is Counting Sort?",
    "keywords": ["counting", "sort", "keys", "frequency"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Counting Sort is an integer sorting algorithm that operates by counting the number of objects that have each distinct key value."
  },
  {
    "id": 114,
    "question": "Code to reverse a Linked List.",
    "keywords": ["reverse", "linked list", "prev", "next"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "Node* reverse(Node* head) { Node *prev = NULL, *current = head, *next = NULL; while (current != NULL) { next = current->next; current->next = prev; prev = current; current = next; } return prev; }"
  },
  {
    "id": 115,
    "question": "What is a Splay Tree?",
    "keywords": ["splay", "tree", "BST", "accessed"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "A Splay Tree is a self-adjusting binary search tree where the recently accessed element is moved to the root."
  },
  {
    "id": 116,
    "question": "What is Depth of a Node?",
    "keywords": ["depth", "node", "tree", "root"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "The Depth of a node is the number of edges from the root to the node."
  },
  {
    "id": 117,
    "question": "Code to print array elements recursively.",
    "keywords": ["print", "array", "recursion", "elements"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "void printArr(int arr[], int n) { if (n == 0) return; printArr(arr, n - 1); cout << arr[n - 1] << \" \"; }"
  },
  {
    "id": 118,
    "question": "What is an Abstract Data Type (ADT)?",
    "keywords": ["ADT", "abstract", "model", "operations"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "ADT is a logical description of data and operations that can be performed on it, without specifying implementation details."
  },
  {
    "id": 119,
    "question": "What is the complexity of Binary Search?",
    "keywords": ["binary search", "complexity", "O(log n)", "time"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "The time complexity of Binary Search is O(log n)."
  },
  {
    "id": 120,
    "question": "Code to check if Linked List is empty.",
    "keywords": ["empty", "linked list", "check", "head"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "bool isEmpty(Node* head) { return head == NULL; }"
  },
  {
    "id": 121,
    "question": "What is Double Hashing?",
    "keywords": ["double", "hashing", "collision", "probe"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Double Hashing is a collision resolution technique where a second hash function is used to determine the probe sequence."
  },
  {
    "id": 122,
    "question": "What is Cycle Detection?",
    "keywords": ["cycle", "detection", "graph", "loop"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Cycle detection is the algorithmic task of finding a cycle in a sequence of iterated function values or a graph."
  },
  {
    "id": 123,
    "question": "Code to convert string to integer.",
    "keywords": ["convert", "string", "int", "stoi"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int num = stoi(str);"
  },
  {
    "id": 124,
    "question": "What is a Sparse Graph?",
    "keywords": ["sparse", "graph", "edges", "vertices"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Sparse Graph is a graph where the number of edges is much less than the maximum possible number of edges."
  },
  {
    "id": 125,
    "question": "What is a Dense Graph?",
    "keywords": ["dense", "graph", "edges", "vertices"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Dense Graph is a graph where the number of edges is close to the maximum possible number of edges."
  },
  {
    "id": 126,
    "question": "Code to find second largest element.",
    "keywords": ["second", "largest", "array", "find"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "sort(arr, arr + n); return arr[n-2];"
  },
  {
    "id": 127,
    "question": "What is In-place Sorting?",
    "keywords": ["in-place", "sorting", "memory", "extra"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "In-place sorting sorts the data within the original structure using only a constant amount of extra memory."
  },
  {
    "id": 128,
    "question": "What is Stable Sorting?",
    "keywords": ["stable", "sorting", "order", "equal"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Stable Sorting maintains the relative order of records with equal keys."
  },
  {
    "id": 129,
    "question": "Code to check if array is sorted.",
    "keywords": ["check", "sorted", "array", "loop"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "bool isSorted(int arr[], int n) { for(int i=0; i<n-1; i++) if(arr[i] > arr[i+1]) return false; return true; }"
  },
  {
    "id": 130,
    "question": "What is Floyd-Warshall Algorithm?",
    "keywords": ["floyd", "warshall", "shortest path", "all-pairs"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "Floyd-Warshall is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights (but no negative cycles)."
  },
  {
    "id": 131,
    "question": "What is Bellman-Ford Algorithm?",
    "keywords": ["bellman", "ford", "shortest path", "negative"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "Bellman-Ford computes shortest paths from a single source vertex to all other vertices, capable of handling negative weights."
  },
  {
    "id": 132,
    "question": "Code to implement Queue using Stack.",
    "keywords": ["queue", "stack", "implement", "two"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "class Queue { stack<int> s1, s2; void enQueue(int x) { s1.push(x); } int deQueue() { if (s1.empty() && s2.empty()) return -1; if (s2.empty()) { while (!s1.empty()) { s2.push(s1.top()); s1.pop(); } } int x = s2.top(); s2.pop(); return x; } }"
  },
  {
    "id": 133,
    "question": "What is a Threaded Binary Tree?",
    "keywords": ["threaded", "binary tree", "traversal", "stack"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "A Threaded Binary Tree makes inorder traversal faster and feasible without stack/recursion by using null pointers to point to inorder successor/predecessor."
  },
  {
    "id": 134,
    "question": "What is a Disjoint Set (Union-Find)?",
    "keywords": ["disjoint set", "union-find", "sets", "merge"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Disjoint Set is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets."
  },
  {
    "id": 135,
    "question": "Code to count leaves in a tree.",
    "keywords": ["count", "leaves", "tree", "recursion"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int countLeaves(Node* root) { if(root == NULL) return 0; if(root->left == NULL && root->right == NULL) return 1; return countLeaves(root->left) + countLeaves(root->right); }"
  },
  {
    "id": 136,
    "question": "What is Linear Probing?",
    "keywords": ["linear", "probing", "collision", "hash"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Linear Probing is an open addressing scheme where, on collision, the algorithm checks the next available slot sequentially."
  },
  {
    "id": 137,
    "question": "What is Quadratic Probing?",
    "keywords": ["quadratic", "probing", "collision", "hash"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Quadratic Probing searches for the next slot using a quadratic polynomial (e.g., i^2)."
  },
  {
    "id": 138,
    "question": "Code to find height of a BST.",
    "keywords": ["height", "BST", "max", "recursion"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int height(Node* node) { if (node==NULL) return 0; return 1 + max(height(node->left), height(node->right)); }"
  },
  {
    "id": 139,
    "question": "What is a Binary Heap?",
    "keywords": ["binary", "heap", "complete", "tree"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Binary Heap is a complete binary tree which satisfies the heap property."
  },
  {
    "id": 140,
    "question": "What is KMP Algorithm?",
    "keywords": ["KMP", "pattern", "matching", "string"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "Knuth-Morris-Pratt (KMP) is a string-searching algorithm that searches for occurrences of a pattern within a main text using a prefix table."
  },
  {
    "id": 141,
    "question": "Code to convert infix to postfix.",
    "keywords": ["infix", "postfix", "stack", "convert"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "code",
    "answer": "// Standard stack-based algorithm involving precedence checks"
  },
  {
    "id": 142,
    "question": "What is Postfix Notation?",
    "keywords": ["postfix", "notation", "RPN", "operator"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Postfix Notation (Reverse Polish Notation) places operators after their operands (e.g., AB+)."
  },
  {
    "id": 143,
    "question": "What is Prefix Notation?",
    "keywords": ["prefix", "notation", "polish", "operator"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Prefix Notation places operators before their operands (e.g., +AB)."
  },
  {
    "id": 144,
    "question": "Code to evaluate postfix expression.",
    "keywords": ["evaluate", "postfix", "stack", "math"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "// Stack based evaluation: push operands, pop two on operator, push result"
  },
  {
    "id": 145,
    "question": "What is Tree Traversal?",
    "keywords": ["tree", "traversal", "visit", "nodes"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Tree Traversal is the process of visiting each node in a tree data structure exactly once."
  },
  {
    "id": 146,
    "question": "What is Graph Traversal?",
    "keywords": ["graph", "traversal", "BFS", "DFS"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Graph Traversal is the process of visiting all the nodes of a graph."
  },
  {
    "id": 147,
    "question": "Code to print reverse of Linked List using recursion.",
    "keywords": ["reverse", "print", "linked list", "recursion"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "void reversePrint(Node* head) { if (head == NULL) return; reversePrint(head->next); cout << head->data << \" \"; }"
  },
  {
    "id": 148,
    "question": "What is the Time Complexity of Insertion Sort?",
    "keywords": ["insertion sort", "time", "complexity", "O(n^2)"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "The worst and average case time complexity is O(n^2)."
  },
  {
    "id": 149,
    "question": "What is Tail Recursion?",
    "keywords": ["tail", "recursion", "last", "call"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Tail Recursion is a special case of recursion where the recursive call is the last operation in the function."
  },
  {
    "id": 150,
    "question": "Code to rotate array by k positions.",
    "keywords": ["rotate", "array", "k", "shift"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "void rotate(int arr[], int d, int n) { reverse(arr, arr+d); reverse(arr+d, arr+n); reverse(arr, arr+n); }"
  },
  {
    "id": 151,
    "question": "What is Circular Queue?",
    "keywords": ["circular", "queue", "ring", "buffer"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Circular Queue is a linear data structure where the last position is connected back to the first to make a circle."
  },
  {
    "id": 152,
    "question": "What is Dequeue Operation?",
    "keywords": ["dequeue", "remove", "front", "queue"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Dequeue is the operation of removing an element from the front of the queue."
  },
  {
    "id": 153,
    "question": "Code to implement simple queue.",
    "keywords": ["queue", "array", "simple", "linear"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "// Basic array implementation with front and rear indices"
  },
  {
    "id": 154,
    "question": "What is Static Array?",
    "keywords": ["static", "array", "fixed", "compile-time"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Static Array has a fixed size determined at compile time."
  },
  {
    "id": 155,
    "question": "What is Dynamic Array?",
    "keywords": ["dynamic", "array", "resize", "runtime"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Dynamic Array can resize itself during runtime (e.g., C++ Vector, Java ArrayList)."
  },
  {
    "id": 156,
    "question": "Code to sort string.",
    "keywords": ["sort", "string", "algorithm", "order"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "sort(str.begin(), str.end());"
  },
  {
    "id": 157,
    "question": "What is Row-Major Order?",
    "keywords": ["row-major", "array", "storage", "memory"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Row-Major Order stores multidimensional arrays in memory row by row."
  },
  {
    "id": 158,
    "question": "What is Column-Major Order?",
    "keywords": ["column-major", "array", "storage", "memory"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Column-Major Order stores multidimensional arrays in memory column by column."
  },
  {
    "id": 159,
    "question": "Code to check if number is power of 2.",
    "keywords": ["power", "2", "bitwise", "check"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "bool isPowerOfTwo(int n) { return n > 0 && (n & (n - 1)) == 0; }"
  },
  {
    "id": 160,
    "question": "What is a Perfect Binary Tree?",
    "keywords": ["perfect", "binary tree", "filled", "leaves"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Perfect Binary Tree is one where all internal nodes have two children and all leaves are at the same level."
  },
  {
    "id": 161,
    "question": "What is Path Compression?",
    "keywords": ["path", "compression", "union-find", "optimization"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "Path Compression is an optimization in Disjoint Set to flatten the tree structure whenever Find is called."
  },
  {
    "id": 162,
    "question": "Code to calculate sum of digits.",
    "keywords": ["sum", "digits", "recursion", "math"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int sumDigits(int n) { return n == 0 ? 0 : n % 10 + sumDigits(n / 10); }"
  },
  {
    "id": 163,
    "question": "What is Rabin-Karp Algorithm?",
    "keywords": ["rabin-karp", "hashing", "string", "search"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "Rabin-Karp is a string-searching algorithm that uses hashing to find patterns in text."
  },
  {
    "id": 164,
    "question": "What is Euclidean Algorithm?",
    "keywords": ["euclidean", "gcd", "algorithm", "math"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Euclidean Algorithm is an efficient method for computing the greatest common divisor (GCD) of two numbers."
  },
  {
    "id": 165,
    "question": "Code to find LCM.",
    "keywords": ["lcm", "gcd", "math", "formula"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "code",
    "answer": "int lcm(int a, int b) { return (a * b) / gcd(a, b); }"
  },
  {
    "id": 166,
    "question": "What is a Weighted Graph?",
    "keywords": ["weighted", "graph", "edge", "cost"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Weighted Graph is a graph where each edge is assigned a numerical value (weight/cost)."
  },
  {
    "id": 167,
    "question": "What is an Undirected Graph?",
    "keywords": ["undirected", "graph", "edge", "direction"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "An Undirected Graph is a graph where edges have no direction (relationships are two-way)."
  },
  {
    "id": 168,
    "question": "Code to reverse a queue.",
    "keywords": ["reverse", "queue", "recursion", "stack"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "void reverseQueue(queue<int>& q) { if (q.empty()) return; int x = q.front(); q.pop(); reverseQueue(q); q.push(x); }"
  },
  {
    "id": 169,
    "question": "What is a Directed Graph (Digraph)?",
    "keywords": ["directed", "graph", "arrow", "direction"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A Directed Graph is a graph where edges have a direction (arrows)."
  },
  {
    "id": 170,
    "question": "What is Breadth-First Traversal?",
    "keywords": ["BFS", "breadth", "level", "queue"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Another name for BFS, traversing graph/tree layer by layer."
  },
  {
    "id": 171,
    "question": "Code to count edges in undirected graph.",
    "keywords": ["count", "edges", "graph", "degree"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "Sum of degrees / 2"
  },
  {
    "id": 172,
    "question": "What is Tree Diameter?",
    "keywords": ["tree", "diameter", "longest", "path"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "The Diameter of a tree is the number of nodes on the longest path between two end nodes."
  },
  {
    "id": 173,
    "question": "What is Depth of Binary Tree?",
    "keywords": ["depth", "tree", "height", "level"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Same as height, usually max level of any leaf."
  },
  {
    "id": 174,
    "question": "Code to check if tree is BST.",
    "keywords": ["check", "BST", "validate", "range"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "bool isBST(Node* root, Node* l=NULL, Node* r=NULL) { if (!root) return true; if (l && root->val <= l->val) return false; if (r && root->val >= r->val) return false; return isBST(root->left, l, root) && isBST(root->right, root, r); }"
  },
  {
    "id": 175,
    "question": "What is Preorder Predecessor?",
    "keywords": ["preorder", "predecessor", "tree", "previous"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "The node visited just before the given node in a Preorder traversal."
  },
  {
    "id": 176,
    "question": "What is Inorder Successor?",
    "keywords": ["inorder", "successor", "tree", "next"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "The node visited just after the given node in an Inorder traversal."
  },
  {
    "id": 177,
    "question": "Code to find min in stack.",
    "keywords": ["min", "stack", "auxiliary", "O(1)"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "code",
    "answer": "// Using auxiliary stack to track min values"
  },
  {
    "id": 178,
    "question": "What is a Trie used for?",
    "keywords": ["trie", "autocomplete", "spell", "dictionary"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Tries are commonly used for autocomplete, spell checking, and IP routing."
  },
  {
    "id": 179,
    "question": "What is the worst case of BST search?",
    "keywords": ["BST", "worst", "skewed", "O(n)"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "O(n) when the tree is skewed (essentially a linked list)."
  },
  {
    "id": 180,
    "question": "Code to copy a linked list.",
    "keywords": ["copy", "linked list", "clone", "new"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "// Iterate and create new nodes"
  },
  {
    "id": 181,
    "question": "What is Heapify?",
    "keywords": ["heapify", "process", "heap", "property"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "Heapify is the process of creating a heap data structure from a binary tree."
  },
  {
    "id": 182,
    "question": "What is Max-Heap?",
    "keywords": ["max-heap", "root", "largest", "parent"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Max-Heap is a binary heap where the root is the largest element."
  },
  {
    "id": 183,
    "question": "Code to implement stack using queues.",
    "keywords": ["stack", "queue", "implement", "two"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "// Use two queues, push to q2, move q1 to q2, swap"
  },
  {
    "id": 184,
    "question": "What is Min-Heap?",
    "keywords": ["min-heap", "root", "smallest", "parent"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A Min-Heap is a binary heap where the root is the smallest element."
  },
  {
    "id": 185,
    "question": "What is an Expression Tree?",
    "keywords": ["expression", "tree", "leaves", "operators"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A binary tree used to represent expressions where leaves are operands and internal nodes are operators."
  },
  {
    "id": 186,
    "question": "Code to remove nth node from end of list.",
    "keywords": ["remove", "nth", "end", "linked list"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "// Two pointer approach"
  },
  {
    "id": 187,
    "question": "What is Level of a Node?",
    "keywords": ["level", "node", "tree", "depth"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "The level of a node is 1 + the number of edges between the node and the root."
  },
  {
    "id": 188,
    "question": "What is Sibling Node?",
    "keywords": ["sibling", "node", "parent", "same"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Nodes that share the same parent."
  },
  {
    "id": 189,
    "question": "Code to swap nodes in Linked List.",
    "keywords": ["swap", "nodes", "linked list", "links"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "code",
    "answer": "// Adjust pointers to swap position"
  },
  {
    "id": 190,
    "question": "What is Internal Node?",
    "keywords": ["internal", "node", "tree", "child"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Any node of a tree that has child nodes."
  },
  {
    "id": 191,
    "question": "What is Degree of a Tree?",
    "keywords": ["degree", "tree", "max", "children"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "The maximum degree of a node in the tree."
  },
  {
    "id": 192,
    "question": "Code to find intersection point of two linked lists.",
    "keywords": ["intersection", "linked list", "point", "merge"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "code",
    "answer": "// Difference in length approach"
  },
  {
    "id": 193,
    "question": "What is Ancestor Node?",
    "keywords": ["ancestor", "node", "parent", "path"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Any node on the path from the root to that node."
  },
  {
    "id": 194,
    "question": "What is Descendant Node?",
    "keywords": ["descendant", "node", "child", "subtree"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "Any node in the subtree rooted at that node."
  },
  {
    "id": 195,
    "question": "Code to clone a graph.",
    "keywords": ["clone", "graph", "BFS", "DFS"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "code",
    "answer": "// Use map to store copies of visited nodes"
  },
  {
    "id": 196,
    "question": "What is Subtree?",
    "keywords": ["subtree", "tree", "child", "descendants"],
    "difficulty": "easy",
    "max_score": 5,
    "type": "theory",
    "answer": "A tree consisting of a node and all its descendants."
  },
  {
    "id": 197,
    "question": "What is Connected Graph?",
    "keywords": ["connected", "graph", "path", "vertices"],
    "difficulty": "medium",
    "max_score": 10,
    "type": "theory",
    "answer": "A graph where there is a path between every pair of vertices."
  },
  {
    "id": 198,
    "question": "Code to serialize a tree.",
    "keywords": ["serialize", "tree", "string", "convert"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "code",
    "answer": "// Store traversal in string/file"
  },
  {
    "id": 199,
    "question": "What is Articulation Point?",
    "keywords": ["articulation", "point", "cut", "vertex"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "theory",
    "answer": "A vertex which, if removed, increases the number of connected components."
  },
  {
    "id": 200,
    "question": "Code to deserialize a tree.",
    "keywords": ["deserialize", "tree", "construct", "string"],
    "difficulty": "hard",
    "max_score": 15,
    "type": "code",
    "answer": "// Reconstruct tree from string"
  }
]